% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/serialization.R
\name{serialize}
\alias{serialize}
\title{Serialize the constructed emulator}
\usage{
serialize(object, light = TRUE)
}
\arguments{
\item{object}{an instance of the S3 class \code{gp}, \code{dgp}, \code{lgp}, or \code{bundle}.}

\item{light}{a bool indicating if a light version of the constructed emulator (that requires a small storage) will be serialized.
Defaults to \code{TRUE}.}
}
\value{
A serialized version of \code{object}.
}
\description{
This function serialize the constructed emulator.
}
\details{
See further examples and tutorials at \url{https://mingdeyu.github.io/dgpsi-R/dev/}.
}
\note{
Since the constructed emulators are 'python' objects, they cannot be directly exported to other R processes for parallel
processing in multi-session workers. This function provides a way to convert the emulators into serialized objects, which can be
restored using \code{\link[=deserialize]{deserialize()}} for multi-session processing.
}
\examples{
\dontrun{

library(future)
library(future.apply)
library(dgpsi)

# Model
f <- function(x) {
 (sin(7.5*x)+1)/2
}

# Training data
X <- seq(0, 1, length = 10)
Y <- sapply(X, f)

# Training a DGP emulator
m <- dgp(X, Y, name = "matern2.5")

X_dgp <- seq(0, 1, length = 100)

# Serialize the DGP emulator
m_serialized <- serialize(m)

# Start a multi-session with three cores for parallel predictions
plan(multisession, workers = 3)

# Perform parallel predictions
results <- future_lapply(1:length(X_dgp), function(i) {
  m_deserialized <- deserialize(m_serialized)
  mean_i <- predict(m_deserialized, X_dgp[i])$results$mean
}, future.seed = TRUE)

# Reset the future plan to sequential
plan(sequential)

# combine mean predictions
pred_mean <- do.call(rbind, results)
}
}
